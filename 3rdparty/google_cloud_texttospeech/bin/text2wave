#!/usr/bin/env python

import argparse
from distutils.version import LooseVersion
import hashlib
import os
import shutil
import sys

from google.cloud.texttospeech import TextToSpeechClient
import pkg_resources
import rospy


# The submodules enums and types have been removed from v2.0.0
# https://github.com/googleapis/python-texttospeech/blob/master/UPGRADING.md#enums-and-types  # NOQA
texttospeech_version = pkg_resources.get_distribution(
    "google-cloud-texttospeech").version
if LooseVersion(texttospeech_version) >= LooseVersion('2.0.0'):
    from google.cloud.texttospeech import AudioConfig
    from google.cloud.texttospeech import AudioEncoding
    from google.cloud.texttospeech import SsmlVoiceGender
    from google.cloud.texttospeech import SynthesisInput
    from google.cloud.texttospeech import VoiceSelectionParams
else:
    import google.cloud.texttospeech
    AudioEncoding = google.cloud.texttospeech.enums.AudioEncoding
    SsmlVoiceGender = google.cloud.texttospeech.enums.SsmlVoiceGender
    AudioConfig = google.cloud.texttospeech.types.AudioConfig
    SynthesisInput = google.cloud.texttospeech.types.SynthesisInput
    VoiceSelectionParams = google.cloud.texttospeech.types.VoiceSelectionParams

cache_enabled = os.environ.get(
    'GOOGLE_CLOUD_TEXTTOSPEECH_CACHE_ENABLED', True)
cache_enabled = cache_enabled is True \
    or cache_enabled == 'true'  # for launch env tag.


def get_cache_dir():
    """Return cache dir.

    Returns
    -------
    cache_dir : str
        cache directory.
    """
    ros_home = os.getenv('ROS_HOME', os.path.expanduser('~/.ros'))
    pkg_ros_home = os.path.join(ros_home, 'google_cloud_texttospeech')
    default_cache_dir = os.path.join(pkg_ros_home, 'cache')
    cache_dir = os.environ.get(
        'GOOGLE_CLOUD_TEXTTOSPEECH_CACHE_DIR',
        default_cache_dir)
    if not os.path.exists(cache_dir):
        os.makedirs(cache_dir)
    return cache_dir


def checksum_md5(filename, blocksize=8192):
    """Calculate md5sum.

    Parameters
    ----------
    filename : str or pathlib.Path
        input filename.
    blocksize : int
        MD5 has 128-byte digest blocks (default: 8192 is 128x64).

    Returns
    -------
    md5 : str
        calculated md5sum.
    """
    filename = str(filename)
    hash_factory = hashlib.md5()
    with open(filename, 'rb') as f:
        for chunk in iter(lambda: f.read(blocksize), b''):
            hash_factory.update(chunk)
    return hash_factory.hexdigest()


if __name__ == '__main__':
    speaking_rate = rospy.get_param('~speaking_rate', 1.0)
    parser = argparse.ArgumentParser(description='')
    parser.add_argument('-eval', '--evaluate')
    parser.add_argument('-o', '--output')
    parser.add_argument('text')
    args = parser.parse_args()

    # Instantiates a client
    client = TextToSpeechClient()

    with open(args.text, 'rb') as f:
        speach_text = f.readline()
    synthesis_input = SynthesisInput(
        text=speach_text)

    # English as default
    language_code = 'en-US'
    name = 'en-US-Wavenet-A'
    # You can see which language is available here
    # https://cloud.google.com/text-to-speech/docs/voices
    # Japanese
    if args.evaluate in ['(ja)', '(ja-JP)']:
        language_code = 'ja-JP'
        name = 'ja-JP-Wavenet-A'

    if cache_enabled:
        cache_dir = get_cache_dir()
        md5 = checksum_md5(args.text)
        cache_filename = os.path.join(
            cache_dir,
            '--'.join([md5, language_code, name, str(speaking_rate)])
            + '.mp3')
        if os.path.exists(cache_filename):
            print('[Text2Wave] Using cached sound file ({}) for {}'
                  .format(cache_filename, speach_text.decode('utf-8')))
            shutil.copy(cache_filename, args.output)
            sys.exit(0)

    voice = VoiceSelectionParams(
        language_code=language_code,
        name=name,
        ssml_gender=SsmlVoiceGender.FEMALE)

    # Select the type of audio file you want returned
    audio_config = AudioConfig(
        audio_encoding=AudioEncoding.MP3,
        speaking_rate=speaking_rate)
    if LooseVersion(texttospeech_version) >= LooseVersion('2.0.0'):
        response = client.synthesize_speech(
            input=synthesis_input,
            voice=voice,
            audio_config=audio_config)
    else:
        response = client.synthesize_speech(
            synthesis_input, voice, audio_config)
    with open(args.output, 'wb') as out:
        # Write the response to the output file.
        out.write(response.audio_content)
    if cache_enabled:
        shutil.copy(args.output, cache_filename)
